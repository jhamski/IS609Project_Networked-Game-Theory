---
title: "IS609 - Networked Game Theory - Final Project"
author: "J. Hamski, S. Hong, H. Berk"
date: "April 9, 2016"
output: html_document
---

```{r, message=FALSE, warning=FALSE, echo=FALSE}
library(igraph)
library(ggplot2)
library(knitr)
```

# Introduction

Game theory is applied in economics, political science, biology and a range of other discriplines to study how rational decision makers interact. The canonical example of game theory is the Prisoner's Dilemma. 

Two things stick out when making the leap from a toy example like the Prisoner's Dilemma and a real-world example like a market:  
* Most market participants don't play multiple games against the same opponent, they play only one or perhaps several over time.  
* Most market participants don't play against just one opponent, they play against several.  

These "n-person" games can utilize Graph Theory to allow for games to be played on networks that reflect realistic human relationships. 



# Prisoner's Dilemma on a Graph.

In the classic two person Prisoner's Dilemma . 

```{r}
nodes <- 16
degree <- 2
g.1 <- degree.sequence.game(rep(degree, nodes), method =  "vl")

#randomply select strategy
# 1 = defect, 2 = cooperate
V(g.1)$strategy <- sample(c(1,2), size = length(V(g.1)), replace = T)

V(g.1)[strategy == 1]$color <- 'red' # defect
V(g.1)[strategy == 2]$color <- 'blue' # cooperate
```

```{r}
plot(g.1)
```


```{r}
max.degree <- function(g){
  
  degree.list <- NULL
  
  for(i in V(g)){
    degree.list <- c(degree.list, degree(g = g, v = i))
  }
  
  return(max(degree.list))
}
```


```{r}
network.evaluation <- function(g, nodes){
  network.results <- NULL
  
  max.degree <- max.degree(g)
  
  for(i in 1:nodes){
    
    opponents <- neighbors(g, i, mode="all")
    opponent.results <- array(NA, max.degree)
    
    for(j in 1:length(opponents)){
      opponent.results[j] <- opponents[j]$strategy
    }
    network.results <- rbind(network.results, opponent.results)
  }
  return(network.results)
}
```


```{r}
game.evaluation <- function(results, nodes, g){
  row.names(results) <- 1:nodes
  results <- cbind(results, V(g)$strategy)
  
  sentence.list <- NULL
  
  for(i in 1:length(results[,1])){
    if(results[i,1] == 1){ #row defects
        opponent.sum <- sum(results[i,-1])
        if(opponent.sum == 2){sentence.list = c(sentence.list, 0)}
        if(opponent.sum == 3){sentence.list = c(sentence.list, 6)}
        if(opponent.sum == 4){sentence.list = c(sentence.list, 12)}
    }
    else{
        opponent.sum <- sum(results[i,-1])
        if(opponent.sum == 2){sentence.list = c(sentence.list, 1)}
        if(opponent.sum == 3){sentence.list = c(sentence.list, 4)}
        if(opponent.sum == 4){sentence.list = c(sentence.list, 8)}
    }
  }
  return(sentence.list)
}
```


```{r}
r <- network.evaluation(g.1, nodes)
r.list <- game.evaluation(r, nodes, g.1)
```


```{r}
results.graph <- function(results.list, nodes, g){
  for(i in 1:nodes){
    V(g)[i]$result <- results.list[i]
  }
  return(g)
}
```

```{r}
g.results <- results.graph(r.list, nodes, g.1)

results <- cbind(1:nodes, V(g.results)$result)
colnames(results) <-c("Node", "Years Sentenced")
kable(results)
```



```{r}
V(g.results)[result == 0]$color <- '#00B2E5' 
V(g.results)[result == 1]$color <- '#2696B7' 
V(g.results)[result == 4]$color <- '#4C7B89' 
V(g.results)[result == 6]$color <- '#72605B' 
V(g.results)[result == 8]$color <- '#98452D' 
V(g.results)[result == 12]$color <- '#BF2A00' 
```


```{r}
plot(g.results)
```




However, if you think of most human networks, they aren't going to be modeled by a ring where every person has two connections. Instead, they may resemble a Barabási–Albert model - a random, scale-free newtwork that commonly arises in human networks. 

```{r}
size = 20
set.seed(2913)
g <- barabasi.game(size, power = 0.6, m = 1)

V(g)$strategy <- sample(c(1,2), size = length(V(g)), replace = T)

plot(g)
```

Find the 'Footsoldiers' - nodes with degree of one. 
```{r}
one.degree <- function(g){
  degree.list <- NULL
  
  for(i in V(g)){
    if(degree(g = g, v = i) == 1){
      degree.list <- c(degree.list, i)
    }
  }
  return(degree.list)
}
```

```{r}
footsoldiers <- one.degree(g)
```

Give each Footsolier a small degree of defection. 
```{r}
for(i in 1:size){
  if(V(g)[i] %in% footsoldiers){
    V(g)[i]$strategy <- sample(c(1,2), size = 1, prob = c(0.4, 0.6))
  }
  else{V(g)[i]$strategy <- NA}
}

for(i in 1:size){
  if(is.na(V(g)$strategy[i]) == TRUE){
    V(g)[i]$color <- 'black'
  }
  else{
    if(V(g)$strategy[i] == 1){
      V(g)[i]$color <- 'red'
    }
    if(V(g)$strategy[i] == 2){
      V(g)[i]$color <- 'blue'
    }
  }
}

plot(g)
```

Take each Wiseguy the Footsoldiers either did or didn't rat on. If they did rat, there's a 50% chance the Wiseguy rats. If they didn't there's only a 5% chance the Wiseguy rats. 

```{r}
next.list <- NULL
for(i in 1:nodes){
  opponents <- neighbors(g, i, mode="all")
  if(length(opponents$strategy[is.na(opponents$strategy) == TRUE]) == 
     length(opponents$strategy)){next}
  else{      
    #get index for the next round of evaluation
    next.list <- c(next.list, i)
  }
}
```

```{r}
for(i in next.list){
  opponents <- neighbors(g, i, mode="all")
  print(i)
  print(opponents$strategy)
}
```




### Code Scrapyard

```{r}
#works
r <- network.evaluation(g, size)
```


```{r}
game.evaluation.any <- function(results, nodes, g){
  row.names(results) <- 1:nodes
  results <- cbind(results, V(g)$strategy)
  
  sentence.list <- NULL
  
  for(i in 1:length(results[,1])){
    if(results[i,1] == 1){ #row defects
        opponent.sum <- sum(results[i,-1])
        if(opponent.sum == 2){sentence.list = c(sentence.list, 0)}
        if(opponent.sum == 3){sentence.list = c(sentence.list, 6)}
        if(opponent.sum == 4){sentence.list = c(sentence.list, 12)}
    }
    else{
        opponent.sum <- sum(results[i,-1])
        if(opponent.sum == 2){sentence.list = c(sentence.list, 1)}
        if(opponent.sum == 3){sentence.list = c(sentence.list, 4)}
        if(opponent.sum == 4){sentence.list = c(sentence.list, 8)}
    }
  }
  return(sentence.list)
}
```
